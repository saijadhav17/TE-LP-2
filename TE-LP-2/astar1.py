import copy

INFINITY: int = 1e10


class Puzzle:
    def __init__(self, elements: list[list[int]]) -> None:
        self.board = elements #board: Represents the arrangement of elements (numbers from 1 to 8) in the puzzle.
        self.n_dims = len(elements) #n_dims: Represents the dimensions of the puzzle (number of rows or columns).
        for i in range(self.n_dims):
            for j in range(self.n_dims):
                if self.board[i][j] == 0:
                    self.pos = (i, j) #pos: Represents the position of the empty cell (denoted by '0') in the puzzle.
                    break

    def print(self):
        for row in self.board:
            print(" ".join(map(str, row)))

    def __eq__(self, other):
        return self.board == other.board

    def __hash__(self):
        return hash(str(self.board))


def move(puzzle): # -> list[Puzzle]
#This function generates all possible states (nodes) that can be reached from a given puzzle state by moving the empty cell in all four directions (up, down, left, right).
#It returns a list of new puzzle states (nodes) generated by the possible moves.
    x, y = puzzle.pos[0], puzzle.pos[1]
    dim = puzzle.n_dims
    possible_pos = [
        (x + 1, y),
        (x, y + 1),
        (x - 1, y),
        (x, y - 1),
    ]
    new_states = []
    for pos_x, pos_y in possible_pos:
        if 0 <= pos_x < dim and 0 <= pos_y < dim:
            new_elements = copy.deepcopy(puzzle.board)
            new_elements[pos_x][pos_y], new_elements[x][y] = (
                new_elements[x][y],
                new_elements[pos_x][pos_y],
            )
            new_states.append(Puzzle(new_elements))
    return new_states


def heuristic(init_puzzle, goal_puzzle) -> int:
#This function calculates a heuristic value for the given puzzle state, representing the estimated cost from the initial puzzle state to the goal puzzle state.
#The heuristic used here is the count of misplaced elements compared to the goal puzzle state.
    return sum(
        1 for i in range(init_puzzle.n_dims)
        for j in range(init_puzzle.n_dims)
        if init_puzzle.board[i][j] != goal_puzzle.board[i][j]
    )



def is_goal(curr_puzzle, goal_puzzle) -> bool:
#This function checks whether the current puzzle state matches the goal puzzle state, indicating whether the goal has been reached.
    return curr_puzzle == goal_puzzle


init_puzzle = Puzzle([[1, 2, 3], [0, 4, 6], [7, 5, 8]])
print("Initial state:")
init_puzzle.print()

goal_puzzle = Puzzle([[1, 2, 3], [4, 5, 6], [7, 8, 0]])
print("Goal state:")
goal_puzzle.print()

print("-----------------------------")

open_set = [init_puzzle]
visited = set()
visited.add(init_puzzle)

num_step = 1
while open_set:
    print(f">> Step {num_step}: ")

    current = min(open_set, key=lambda x: heuristic(x, goal_puzzle))
    current.print()

    num_step += 1

    if is_goal(current, goal_puzzle):
        print("Done")
        break

    print(">> Possible states: ")
    open_set.remove(current)
    for neighbor in move(current):
        if neighbor not in visited:
            visited.add(neighbor)
            open_set.append(neighbor)
            neighbor.print()
            print(f"h(n) for above state is {heuristic(neighbor, goal_puzzle)}")
            print(f"g(n) for above state is {num_step}")
            print(f"f(n) for above state is {num_step + heuristic(neighbor, goal_puzzle)}")

    print("-----------------------------")
